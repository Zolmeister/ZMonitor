var libfs = require( 'fs' );

var readStat = function( cb ) {
	libfs.readFile( "/proc/stat", function( err, data ) {
		cb( data.toString( ) );
	} );
}
function stop(){
    if(interval){
        clearInterval(interval);
    }
}

function cpuUsage( freq, cb ) {
	
	if( typeof freq == 'function' ) {
		cb = freq;
		freq = 1000;
	}
	
    var cpus={};
    
	interval = setInterval( function( ) {
		readStat( function( data ) {
			var dRaw = data.split( ' ' );
			
			var idx = 1;
    		while (dRaw[idx].indexOf("intr")===-1){
    		    if(dRaw[idx].indexOf("cpu")!=-1){
    		        var id = dRaw[idx].substring(2);
    		        if(typeof cpus[id] ==="undefined")
    		            cpus[id]={}
    		        cpus[id].values = [dRaw[idx+1], dRaw[idx+2], dRaw[idx+3], dRaw[idx+4]].map(function(data){return parseInt(data)});
    		        idx+=4;
    		    }
    		    else{
    		        idx++;
    		    }
    		}
    		var loads = [];
    		for(var i in cpus){
    		    var vals = cpus[i].values;
    		    var idle = vals[3];
    		    var total = vals[0] + vals[1] + vals[2];
    		    var load = 0;
    		    if(typeof cpus[i].total!=='undefined'){
    		        load = Math.round( ( total - cpus[i].total) / ( total + idle - cpus[i].total - cpus[i].idle ) * 100 );
    		        loads.push(load);
    		    }
    		    cpus[i].load = load;
    		    cpus[i].total = total;
    		    cpus[i].idle = idle;
    		}
    		if(loads.length>0 && cb){
    		    cb(loads);
    		}
		} );
	}, freq || 1000 );
};

exports.usage = cpuUsage;
exports.stop = stop;
